#!/bin/sh
#
# $FreeBSD$
#

# PROVIDE: ix-devd
# REQUIRE: ix-zfs
# BEFORE: devd pf

# Copyright (C) iXsystems 2010
# This file is a part of TrueNAS
# and may be copied and/or distributed
# without the express permission of iXsystems.

. /etc/rc.subr

#
# Generate CARP hooks right before mountlate.
#
ix_devd_gen()
{
	local IFS=\|

	local failovers=`${FREENAS_SQLITE_CMD} ${FREENAS_CONFIG} "SELECT COUNT(id) FROM system_failover;"`
	local peerip=`${FREENAS_SQLITE_CMD} ${FREENAS_CONFIG} "SELECT ipaddress FROM system_failover LIMIT 1;"`
	local volumenames=`${FREENAS_SQLITE_CMD} ${FREENAS_CONFIG} "SELECT vol_name FROM storage_volume WHERE vol_fstype = 'ZFS';" | tr "\n" " "`

	if [ ${failovers} -gt 0 ]; then
		cp /conf/base/etc/devd.conf /etc/devd.conf
		cat >> /etc/devd.conf << E*O*F

notify 100 {
   match "system"   "IFNET";
   match "subsystem" "carp.*";
   action "/bin/sh /etc/carp-state-change-hook \$subsystem \$type";
};
E*O*F

ELECTING_FILE="/tmp/.failover_electing"
IMPORTING_FILE="/tmp/.failover_importing"
FAILED_FILE="/tmp/.failover_failed"
FAILOVER_MTX="/tmp/.failover_mtx"
FAILOVER_STATE="/tmp/.failover_state"
FAILOVER_RES_TMPL="/tmp/.failover_result.XXXXXXXX"
FAILOVER_ASSUMED_MASTER="/tmp/.failover_master"

		# Failover script
		cat > /etc/carp-state-change-hook << E*O*F
#!/bin/sh

SUBSYSTEM=\$1
EVENT=\$2

# TODO: for now, these two special carp interfaces for interconnection are hardcoded.
if [ \${SUBSYSTEM} = "carp1" -o \${SUBSYSTEM} = "carp2" ]; then
	exit
fi

if [ \${EVENT} = "LINK_UP" ]; then
	FLAGFILE=\`mktemp ${FAILOVER_RES_TMPL}\`
	lockf -k ${FAILOVER_MTX} sh -c "[ ! -e ${FAILOVER_STATE}\${EVENT} ] && touch ${FAILOVER_STATE}\${EVENT} || rm \${FLAGFILE}"
	if [ ! -e \${FLAGFILE} ]; then
		exit
	else
		rm \${FLAGFILE}
	fi
fi

touch -t \`date -v -1M +%Y%m%d%H%M.%S\` /tmp/heartbeat_barrier

# Has the user indicated we should take over?
if  [ -f /tmp/failover_override ] ; then
    USER_OVERRIDE=1
else
    USER_OVERRIDE=0
fi

IPS=\`${FREENAS_SQLITE_CMD} ${FREENAS_CONFIG} "select int_ipv4address from network_interfaces where int_interface like 'carp%'"\`

# Do we have a force seal?
HAVE_FORCESEAL=\`find /tmp/force_seal -mnewer /tmp/heartbeat_barrier | wc -l\`

if [ \${EVENT} = "LINK_UP" ]; then
    echo "Entering UP on \${SUBSYSTEM}!" | logger

    # We are already master, insist this by setting all advskew to 1
    if [ -e ${FAILOVER_ASSUMED_MASTER} ]; then
	ifconfig -l | tr ' ' '\n' | grep ^carp | grep -v '^carp[12]$' | xargs -n 1 -J % ifconfig % advskew 1
	rm -f ${FAILOVER_STATE}\${EVENT}
	exit 0
    fi

    BACKUPS=\$(ifconfig -l | tr ' ' '\n' | grep ^carp | grep -v '^carp[12]$' | xargs -n 1 ifconfig | grep "carp: BACKUP" | wc -l )
    if [ \${BACKUPS} -gt 0 ]; then
	echo "Ignoring UP state on \${SUBSYSTEM} because we still have interfaces that are BACKUP." | logger
	echo "\$(date), \$(hostname), \${SUBSYSTEM} assumed master while other interfaces are still in slave mode." | mail -s "Failover WARNING" root
	rm -f ${FAILOVER_STATE}\${EVENT}
	exit 1
    fi

    pkill -f fenced

    echo "set block-policy drop" > /etc/pf.conf.block
    echo \${IPS} | xargs -n 1 -J % echo pass in quick proto tcp from any to % port {22, 80, 443} >> /etc/pf.conf.block
    echo \${IPS} | xargs -n 1 -J % echo block drop in quick proto tcp from any to % >> /etc/pf.conf.block
    echo \${IPS} | xargs -n 1 -J % echo block drop in quick proto udp from any to % >> /etc/pf.conf.block
    pfctl -f /etc/pf.conf.block

    rm -f ${FAILED_FILE} ${IMPORTING_FILE}
    touch ${ELECTING_FILE}

    # Was the other peer UP in the last minute?
    WASCONNECTED=\`find /tmp/heartbeat_state -mnewer /tmp/heartbeat_barrier | wc -l\`
    FASTTRACK=0

    # If the other peer was up, test if it's down and we can go with fast route
    if [ \${WASCONNECTED} -eq 1 ] ; then
	sleep 1
	STATUS0=\`ifconfig \${SUBSYSTEM} | grep "carp:" | awk '{print \$2}'\`
	STATUS1=\`(ifconfig carp1 | grep carp: | awk '{print \$2;}' ; ifconfig carp2 | grep carp: | awk '{print \$2;}')| grep -E '(MASTER|INIT)' | wc -l\`
	STATUS2=\`(ifconfig carp1 | grep carp: | awk '{print \$2;}' ; ifconfig carp2 | grep carp: | awk '{print \$2;}')| grep BACKUP | wc -l\`

	echo "Status: \${STATUS0}:\${STATUS1}:\${STATUS2}" | logger

	if [ \$STATUS0 != "MASTER" ]; then
	    echo "Promoted then demoted, quitting." | logger
	    # Just in case.  Demote ourselves.
	    ifconfig \${SUBSYSTEM} advskew 202
	    rm -f ${ELECTING_FILE} ${FAILOVER_STATE}\${EVENT}
	    exit
	fi

	# If the other side was down
	if [ \${STATUS1} -eq 2 -a \${STATUS2} -eq 0 ] ; then
	    FASTTRACK=1
	fi
    fi

    if [ \${HAVE_FORCESEAL} -eq 1 ]; then
	FASTTRACK=1
    fi

    # Start fenced.
    # If not forced, start a normal one, otherwise, mark as such.
    echo "Starting fenced." | logger
    RETVAL=Undefined
    /sbin/camcontrol rescan all
    if [ \${USER_OVERRIDE} -eq 0 -a \${FASTTRACK} -eq 0 ] ; then
	/usr/local/bin/python /usr/local/sbin/fenced
	RETVAL=\$?
    else
	/usr/local/bin/python /usr/local/sbin/fenced force
	RETVAL=\$?
    fi

    if [ \${RETVAL} -ne 0 ]; then
	case \${RETVAL} in
	1)
		echo "Can not register keys on disks!" | tee ${FAILED_FILE} | logger
		ifconfig \${SUBSYSTEM} advskew 201
		;;
	2)
		echo "Remote fenced is running!" | tee ${FAILED_FILE} | logger
		ifconfig \${SUBSYSTEM} advskew 202
		;;
	3)
		echo "Can not reserve all disks!" | tee ${FAILED_FILE} | logger
		ifconfig \${SUBSYSTEM} advskew 203
		;;
	*)
		echo "This should never happen: \${RETVAL}" | tee ${FAILED_FILE} | logger
		ifconfig \${SUBSYSTEM} advskew 204
		;;
	esac
	rm -f ${ELECTING_FILE} ${FAILOVER_STATE}\${EVENT}
	exit 1
    fi

    # If we reached here, fenced is daemonized and have all drives reserved.  Bring up all carps we own.
    ifconfig -l | tr ' ' '\n' | grep ^carp | grep -v '^carp[12]$' | xargs -n 1 -J % ifconfig % advskew 1

    touch ${IMPORTING_FILE}
    rm ${ELECTING_FILE}

    # Open every disk for writing once.
    sysctl -n kern.disks | tr ' ' '\n' | grep ^da | xargs -n 1 echo "false >" | sh

    if [ -e /data/zfs/killcache ]; then
	rm -f /data/zfs/zpool.cache /data/zfs/zpool.cache.saved
    else
	touch /data/zfs/killcache
	fsync /data/zfs/killcache
    fi
    if [ -s /data/zfs/zpool.cache ]; then
	if ([ ! -e /data/zfs/zpool.cache.saved ] || [ /data/zfs/zpool.cache -nt /data/zfs/zpool.cache.saved ]); then
	    cp /data/zfs/zpool.cache /data/zfs/zpool.cache.saved
	fi
    fi

    echo "Beginning volume imports." | logger
    for volumename in ${volumenames}; do
        echo "importing \${volumename}" | logger
	[ -e /data/zfs/zpool.cache.saved ] && /sbin/zpool import -c /data/zfs/zpool.cache.saved -o cachefile=none -R /mnt -f \${volumename} || /sbin/zpool import -o cachefile=none -R /mnt -f \${volumename}
	RETVAL=\$?
	if [ \${RETVAL} -ne 0 ]; then
		touch ${FAILED_FILE}
	fi
	/sbin/zpool set cachefile=/data/zfs/zpool.cache \${volumename}
    done
    touch ${FAILOVER_ASSUMED_MASTER}
    rm -f /data/zfs/killcache

    [ ! -e ${FAILED_FILE} ] && cp /data/zfs/zpool.cache /data/zfs/zpool.cache.saved
    rm ${IMPORTING_FILE}
    echo "Volume imports complete." | logger

    #mount -uw /
    echo "Restarting services." | logger
    /usr/local/bin/python /usr/local/www/freenasUI/middleware/notifier.py nfsv4link > /dev/null
    /etc/rc.d/statd quietrestart
    /usr/sbin/service ix-nfsd quietstart
    /usr/sbin/service mountd quietrestart
    /usr/sbin/service nfsd quietrestart
    /usr/sbin/service ix-ctld quietstart
    /usr/sbin/service ctld quietforcestop
    /usr/sbin/service ctld quietstart
    /usr/sbin/service ix-samba quietstart
    /usr/sbin/service samba_server quietforcestop
    /usr/sbin/service samba_server quietstart
    /usr/sbin/service ix-afpd quietstart
    /usr/sbin/service netatalk quietforcestop
    /usr/sbin/service netatalk quietstart
    echo "Service restarts complete." | logger
#
# There appears to be a small lag if we allow NFS traffic right away.  During
# this time, we fail NFS requests with ESTALE to the remote system.  This
# gives remote clients heartburn, so rather than try to deal with the
# downstream effect of that, instead we take a chill pill for 2 seconds.
#
    sleep 1
    truncate -s 0 /etc/pf.conf
    echo \${IPS} | xargs -n 1 -J % echo pass quick from any to % keep state >> /etc/pf.conf
    pfctl -f /etc/pf.conf
    echo "Allowing network traffic." | logger
    echo "\$(date), \$(hostname), assume master" | mail -s "Failover" root

    if  [ -f /tmp/failover_override ] ; then
	rm /tmp/failover_override
    fi
    /usr/sbin/service ix-crontab quietstart
    rm -f ${FAILOVER_STATE}\${EVENT}

    echo "Syncing enclosure" | logger
    /usr/local/bin/python /usr/local/www/freenasUI/middleware/notifier.py zpool_enclosure_sync

    /usr/sbin/service ix-collectd quietstart
    /usr/sbin/service collectd quietrestart
    echo "Failover event complete." | logger
fi

if [ \${EVENT} = "LINK_DOWN" ]; then
    echo "Entering DOWN!" | logger

    MASTERS=\`ifconfig -l | tr ' ' '\n' | grep ^carp | grep -v '^carp[12]$' | xargs -n 1 ifconfig | grep "carp: MASTER" | wc -l \`
    if [ \${MASTERS} -gt 0 ]; then
	echo "Ignoring DOWN state on \${SUBSYSTEM} because we still have interfaces that are UP." | logger
	rm -f ${FAILOVER_STATE}\${EVENT}
	exit 1
    fi

    pkill -f fenced

    ifconfig -l | tr ' ' '\n' | grep ^carp | grep -v '^carp[12]$' | xargs -n 1 -J % ifconfig % advskew 100
    echo "set block-policy drop" > /etc/pf.conf.block
    echo \${IPS} | xargs -n 1 -J % echo pass in quick proto tcp from any to % port {22, 80, 443} >> /etc/pf.conf.block
    echo \${IPS} | xargs -n 1 -J % echo block drop in quick proto tcp from any to % >> /etc/pf.conf.block
    echo \${IPS} | xargs -n 1 -J % echo block drop in quick proto udp from any to % >> /etc/pf.conf.block
    pfctl -f /etc/pf.conf.block
    /etc/rc.d/statd stop
    /etc/rc.d/watchdogd stop
    watchdog -t 4
    for volumename in ${volumenames}; do
	echo "Exporting \${volumename}!" | logger
	zpool export -f \${volumename} || (zpool status \${volumename} && sleep 5)
	echo "Exported \${volumename}!" | logger
    done
    watchdog -t 0
    rm -f ${FAILOVER_ASSUMED_MASTER}

    /etc/rc.d/watchdogd start
    /usr/sbin/service ix-crontab quietstart
    /usr/sbin/service collectd forcestop
    echo "\$(date), \$(hostname), assume backup" | mail -s "Failover" root

    echo "Syncing enclosure" | logger
    /usr/local/bin/python /usr/local/www/freenasUI/middleware/notifier.py zpool_enclosure_sync
fi

E*O*F
	else
		/usr/bin/truncate -s 0 /etc/pf.conf
	fi
}

name="ix-devd"
start_cmd='ix_devd_gen'
stop_cmd=':'

load_rc_config $name
run_rc_command "$1"
