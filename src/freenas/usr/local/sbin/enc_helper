#!/usr/local/bin/python3
#
# Copyright (c) 2015 iXsystems, Inc.
# All rights reserved.
# This file is a part of TrueNAS
# and may not be copied and/or distributed
# without the express permission of iXsystems.

import argparse
import logging
import sys
import subprocess
import getpass

from middlewared.client import Client


def jb_callback(job):
    print(job["progress"]["description"])


def run(cmd):
    proc = subprocess.Popen(
        cmd,
        stderr=subprocess.PIPE,
        stdout=subprocess.PIPE,
        shell=True,
        encoding='utf8',
    )
    output = proc.communicate()[0]
    return (proc.returncode, output.strip('\n'))


log = logging.getLogger('tools.haenc')

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(help='sub-command help', dest='name')
    subparsers.add_parser('clear', help='Clear the passphrase')
    subparsers.add_parser('synctopeer', help='Transfer local passphrase to remote system')
    subparsers.add_parser('syncfrompeer', help='Transfer remote passphrase to local system')
    subparsers.add_parser('status', help='Inquiry escrow daemon status')
    subparsers.add_parser('attachall', help='Attach all GELI providers with the escrowd passphrase')
    subparsers.add_parser('detachall', help='Detach all GELI providers')
    iparser = subparsers.add_parser('interactive', help='Sets passphrase securely from the CLI for a given pool')
    iparser.add_argument('-k', '--key-only', action='store_true', help='Set the key only, do not force failover')

    args = parser.parse_args()

    cmd = args.name
    rv = "Unknown"
    with Client() as c:
        if cmd == 'clear':
            rv = c.call('failover.encryption_clearkey')
        elif cmd == 'status':
            rv = c.call('failover.encryption_status')
            if rv:
                print("Escrowd has the passphrase")
                log.warn("Escrowd has the passphrase")
            else:
                print("Escrowd is running without the passphrase")
                log.warn("Escrowd is running without the passphrase")
        elif cmd == 'attachall':
            c.call('failover.encryption_attachall', timeout=600, job=True, callback=jb_callback)

        elif cmd == 'detachall':
            job = c.call('failover.encryption_detachall', job='RETURN', callback=jb_callback)
            if job.result() is False:
                sys.exit(1)

        elif cmd == 'interactive':
            pool = input('Please provide pool:')
            passphrase = getpass.getpass()
            if pool and passphrase:
                rv = c.call('failover.encryption_setkey', pool, passphrase)
                try:
                    c.call('failover.sync_keys_with_remote_node')
                except Exception:
                    print("Failed to sync keys with the standby node.")
                    log.warn("Failed to sync keys with the standby node.")
                if not args.key_only:
                    c.call('failover.force_master')
        else:
            where = 'standby' if cmd == 'synctopeer' else 'local'
            cmd_args = ['failover.sync_keys_with_remote_node'] if cmd == 'synctopeer' else [
                'failover.call_remote', 'failover.sync_keys_with_remote_node'
            ]
            try:
                c.call(*cmd_args)
            except Exception as e:
                print(f"ERROR: Failed to sync keys on {where} controller.")
                log.warn("ERROR: Failed to sync keys on %s controller.", where)
                rv = False
            else:
                rv = True

    if rv:
        print("Succeeded")
        sys.exit(0)
    else:
        print("Failed")
        sys.exit(1)
